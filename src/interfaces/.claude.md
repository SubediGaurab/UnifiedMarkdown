# Interfaces Directory (`/src/interfaces`)

## Purpose

Contains **interface definitions** (contracts) that define communication between layers following the **Dependency Inversion Principle**.

## Philosophy

> "Define contracts, not implementations. Depend on abstractions, not concretions."

## Directory Structure

```
interfaces/
└── IOCRService.ts        # OCR service contract
```

**Future interfaces**:
```
interfaces/
├── IOCRService.ts
├── IGeminiOCRService.ts
├── IMarkdownSaverService.ts
└── ICommandHandler.ts
```

## What Are Interfaces?

Interfaces define **WHAT** a component can do, not **HOW** it does it.

They serve as:
- **Contracts** between layers
- **Abstraction boundaries** for testing
- **Extension points** for new implementations

## Current Interfaces

### IOCRService

**Purpose**: Contract for OCR service implementations

**Methods**:
- `extractText(imagePath: string): Promise<void>`

**Implementations**:
- `ImageOCRService`
- `PdfOCRService`
- `DirectoryOCRService`

**Why this design**: Each service handles its own file type strategy and saves directly. Simple, focused contract.

### IGeminiOCRService (defined in GeminiSingleFileOCRService.ts)

**Purpose**: Contract for AI provider integrations

**Methods**:
- `extractText(filePath: string, mimeType: string): Promise<string>`

**Current implementation**:
- `GeminiSingleFileOCRService`

**Future implementations**:
- `ClaudeOCRService`
- `OpenAIOCRService`

## Dependency Inversion Principle (DIP)

### The Problem Without Interfaces

Without interfaces, high-level modules (commands) depend on low-level modules (services):

```
Commands → ImageOCRService (concrete class)
```

This creates tight coupling. Changing the service requires changing commands.

### The Solution With Interfaces

With interfaces, both depend on abstractions:

```
Commands → IOCRService ← ImageOCRService
           (interface)    (implements)
```

High-level and low-level modules both depend on the interface.

## Benefits of Interface-Based Design

### 1. Testability

Mock implementations for testing without touching real services.

### 2. Flexibility

Swap implementations without changing client code.

### 3. Multiple Implementations

Different implementations of the same interface can coexist.

### 4. Open/Closed Principle

Open for extension (new implementations), closed for modification (interface remains stable).

## Interface Design Guidelines

### 1. Small and Focused (Interface Segregation)

Interfaces should be minimal. If a client doesn't need a method, it shouldn't be in the interface.

**✅ Good**: Single method interfaces
**❌ Bad**: "God interfaces" with many methods

### 2. Stable Contracts

Interfaces should change rarely. Breaking changes affect all implementations.

### 3. Return Types, Not Errors

Prefer returning result objects over throwing exceptions:

**✅ Good**: `Promise<OCRResult>` where `OCRResult` can contain errors
**❌ Bad**: `Promise<string>` that throws on error

### 4. No Implementation Details

Interfaces should not expose internal implementation details.

## Adding a New Interface

### When to Create an Interface

Create a new interface when:
- You need to abstract a service for testing
- Multiple implementations will exist
- You want to enforce a contract between layers
- You're following Dependency Inversion Principle

### Where to Define Interfaces

- **This directory** (`src/interfaces/`) for contracts used across multiple services
- **With the implementation** for simple, single-use interfaces

### Interface Naming Convention

- Prefix with `I` (e.g., `IOCRService`, `IStorageService`)
- Use noun form (what it IS, not what it DOES)
- Be descriptive and specific

## Liskov Substitution Principle (LSP)

All implementations of an interface must be **substitutable** for each other without breaking functionality.

Example: All `IOCRService` implementations must:
- Accept the same parameters
- Return the same result type
- Have the same behavior contract (not necessarily same implementation)

This ensures you can swap `ImageOCRService` for `PdfOCRService` at runtime if needed.

## Common Anti-Patterns

### ❌ Leaky Abstractions

Don't expose implementation details in interfaces.

### ❌ Empty Interfaces

Don't create marker interfaces with no methods.

### ❌ God Interfaces

Don't create interfaces with too many unrelated methods.

### ❌ Concrete Dependencies

Don't import concrete implementations where interfaces should be used.

## Type Safety

TypeScript enforces interface contracts at compile-time:
- Methods must match signatures
- Return types must match
- Parameters must match

This prevents runtime errors and enables confident refactoring.

---

**See Also**:
- Root `.claude.md` for SOLID principles overview
- `src/.claude.md` for dependency rules
- `services/.claude.md` for interface implementations

**Last Updated**: 2025-11-23
