# Services Directory (`/src/services`)

## Purpose

Services are **business logic and infrastructure layer** components that implement file processing strategies and integrate with external AI APIs. They implement the interfaces defined in `interfaces/` following the **Dependency Inversion Principle**.

## Philosophy

> "Services handle the **HOW** (implementation details), while interfaces define the **WHAT** (contracts)."

## Directory Structure

**Current structure**:
- `AI/` - AI service integrations (Google Gemini)
- `OCR/` - OCR strategy implementations and factory
- `MarkdownSaverService.ts` - Markdown file management

**Future expansion possibilities**:
- Additional OCR strategies (DOCX, spreadsheets, etc.)
- Storage abstraction (local, S3, cloud storage)
- Alternative AI providers (OpenAI GPT-4V, etc.)

## Design Patterns

### 1. Factory Pattern

**Problem**: Need to create different service implementations based on input type (image, PDF, directory).

**Solution**: `OCRServiceFactory` encapsulates service creation logic.

**How it works**:
- Commands request a service from the factory
- Factory inspects the input path (file extension, is it a directory?)
- Factory instantiates and returns the appropriate service
- Command works with the service through the `IOCRService` interface

**Benefits**:
- Centralized creation logic
- Easy to add new file types
- Commands don't need to know about specific service implementations
- Open/Closed Principle: extend without modifying commands

### 2. Strategy Pattern

**Problem**: Different file types require different processing approaches.

**Solution**: Each file type has its own OCR service strategy implementing `IOCRService`.

**Current strategies**:
- `ImageOCRService` - Processes image files (PNG, JPG, etc.)
- `PdfOCRService` - Processes PDF documents
- `DirectoryOCRService` - Batch processes all files in a directory

**Benefits**:
- Each strategy optimized for its file type
- Easy to test strategies independently
- Strategies are interchangeable (Liskov Substitution Principle)
- New strategies can be added without modifying existing ones

## Service Layer Organization

### AI Services (`AI/`)

#### GeminiSingleFileOCRService

**Purpose**: Integrates with Google Gemini AI for document digitization.

**Key features**:
- Uses Gemini 3 Pro Preview model
- High thinking level for better quality
- Converts images and PDFs to markdown
- Preserves document structure and formatting

**Design decisions**:
- Environment-based configuration (API key from .env)
- Base64 file encoding for Gemini API
- Descriptive system instructions for consistent output
- Throws errors (handled by OCR services)

### OCR Services (`OCR/`)

#### OCRServiceFactory

**Purpose**: Factory for creating appropriate OCR service based on input type.

**Responsibilities**:
- Determine file type from path/extension
- Instantiate correct service
- Throw error for unsupported types

**Key decisions**:
- Static factory method (no instance state needed)
- File system inspection for directories
- Extension-based routing for files
- Fail fast with clear error messages

#### ImageOCRService

**Purpose**: Strategy for processing image files to markdown.

**Responsibilities**:
- Determine MIME type from file extension
- Use GeminiSingleFileOCRService to extract text
- Use MarkdownSaverService to save output
- Log processing status

**Supported formats**: PNG, JPG, JPEG, WebP, GIF, BMP, TIFF, SVG

#### PdfOCRService

**Purpose**: Strategy for processing PDF files to markdown.

**Responsibilities**:
- Pass PDF to Gemini with application/pdf MIME type
- Handle multi-page documents
- Save markdown output
- Log processing status

#### DirectoryOCRService

**Purpose**: Strategy for batch processing all supported files in a directory.

**Responsibilities**:
- Scan directory for supported files
- Process each file using appropriate strategy
- Handle errors for individual files without stopping batch
- Report overall progress

### File Management

#### MarkdownSaverService

**Purpose**: Handles markdown file creation with automatic backup.

**Key features**:
- Smart backup: renames existing .md files with timestamp
- Consistent output: `<filename>.<ext>.md` format
- Prevents data loss: never overwrites without backup

**Design decisions**:
- Timestamp format: `YYYYMMDD.HHMMSS`
- Synchronous file operations for reliability
- Single responsibility: only handles file I/O

## SOLID Principles in Services

### Single Responsibility Principle (SRP)

Each service has ONE responsibility:
- `GeminiSingleFileOCRService` - Only Gemini AI integration
- `ImageOCRService` - Only image processing
- `PdfOCRService` - Only PDF processing
- `MarkdownSaverService` - Only markdown file I/O

### Open/Closed Principle (OCP)

Add new file types by:
- Creating new OCR service class
- Adding to factory switch statement
- No changes to existing services or commands

### Liskov Substitution Principle (LSP)

All `IOCRService` implementations are interchangeable:
- Same interface contract
- Same method signatures
- Same behavior expectations

### Interface Segregation Principle (ISP)

Services implement minimal interfaces:
- `IOCRService` has single method: `extractText()`
- `IGeminiOCRService` has single method: `extractText(filePath, mimeType)`
- No unnecessary methods

### Dependency Inversion Principle (DIP)

Services implement interfaces defined in `interfaces/` directory, allowing for easy substitution and testing.

## Best Practices for Services

### 1. Error Handling

- Services may throw errors (caught by commands)
- Log errors with context before throwing
- Provide clear error messages

### 2. Configuration

- Use environment variables for API keys
- Never hard-code secrets
- Validate configuration on service initialization

### 3. Logging

- Log start of processing
- Log success/failure
- Use appropriate log levels (info, error, debug)

### 4. Single Responsibility

- Each service does ONE thing
- Extract reusable logic to separate services
- Compose services rather than creating "god services"

### 5. Testability

- Design for dependency injection
- Keep services pure (deterministic)
- Mock external dependencies (AI APIs, file system)

## Adding a New Service

### When to Create a New Service

Create a new service when:
- Supporting a new file type
- Integrating a new external API
- Extracting shared logic from multiple services
- Implementing a new processing strategy

### Steps to Add a New File Type

1. Create new OCR service implementing `IOCRService`
2. Add service to factory's file type detection
3. Test the new service
4. Update documentation

No changes needed in commands or other services.

### Steps to Add a New AI Provider

1. Create new AI service implementing `IGeminiOCRService`
2. Update OCR services to use new provider (if switching)
3. Add environment configuration for new provider
4. Test integration

## Testing Services

### Unit Testing

- Mock external dependencies (Gemini API, file system)
- Test error handling
- Test edge cases (empty files, corrupted files, etc.)

### Integration Testing

- Test with real files
- Test with real AI API (in development)
- Verify markdown output quality

### Testing Strategies

- Test each strategy independently
- Test factory service selection
- Test error propagation through layers

---

**See Also**:
- Root `.claude.md` for overall architecture
- `interfaces/.claude.md` for service contracts
- `commands/.claude.md` for how commands use services

**Last Updated**: 2025-11-23
