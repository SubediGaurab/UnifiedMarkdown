# Commands Directory (`/src/commands`)

## Purpose

Contains **Command Pattern** implementations for the CLI. Each command encapsulates all logic for a specific CLI operation.

## Philosophy

> "Commands are the bridge between the CLI presentation layer and the business logic layer. They orchestrate, they don't implement."

## Directory Structure

```
commands/
├── ConvertCommand.ts     # Primary convert command
└── ImageCommand.ts       # Legacy image command
```

## Design Pattern: Command Pattern

### What is the Command Pattern?

The Command Pattern encapsulates a request as an object, allowing you to:
- Parameterize clients with different requests
- Queue or log requests
- Support undoable operations

### Implementation in UnifiedMarkdown

Each command is registered with Commander.js and handles:
1. **Argument validation**: Resolving paths, checking file existence
2. **Service creation**: Using OCRServiceFactory to get the right service
3. **Execution**: Calling the service's `extractText()` method
4. **Error handling**: Catching and displaying errors to the user

### Current Commands

#### ConvertCommand

- **Command**: `umd convert <inputPath>`
- **Purpose**: Convert image, PDF, or directory to markdown
- **Strategy**: Uses OCRServiceFactory to determine and create appropriate service

#### ImageCommand (Legacy)

- **Command**: `umd image <inputPath>`
- **Purpose**: Original image conversion command
- **Status**: Maintained for backwards compatibility

## Key Principles

### 1. Single Responsibility

Each command handles ONE CLI operation. If you need different behavior, create a new command.

### 2. No Business Logic

Commands orchestrate but don't implement. Business logic belongs in services.

**✅ Correct**: Command calls `service.extractText(path)`
**❌ Wrong**: Command implements text extraction logic

### 3. Dependency on Abstractions

Commands depend on `IOCRService` interface, not concrete implementations.

### 4. Error Boundaries

Commands are the error boundary. They catch service errors and format them for CLI display.

## Adding a New Command

1. **Create command file** in `src/commands/XCommand.ts`
2. **Export registration function** that takes `Command` from Commander.js
3. **Register in CLI** by importing and calling in `src/cli.ts`

**Example structure**:
- Define command with `.command()`, `.description()`, `.option()` (if needed)
- Implement `.action()` handler
- Use try/catch for error handling
- Return exit codes appropriately

## Command vs Service

**Command responsibilities:**
- Parse CLI arguments
- Validate input paths
- Get appropriate service from factory
- Handle errors and display messages
- Manage CLI exit codes

**Service responsibilities:**
- Implement file processing logic
- Call AI APIs
- Save markdown files
- Handle processing errors

## Testing Commands

Commands should be tested for:
- Argument parsing correctness
- Proper service selection via factory
- Error handling and messaging
- Exit code behavior

Mock the factory to test command logic in isolation.

---

**See Also**:
- Root `.claude.md` for overall architecture
- `src/.claude.md` for layer responsibilities
- `services/.claude.md` for service implementations

**Last Updated**: 2025-11-23
