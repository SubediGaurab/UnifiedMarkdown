# Utils Directory (`/src/utils`)

## Purpose

The **utils** directory contains **pure utility functions** and **helper classes** that are reusable across all layers of the application.

## Philosophy

> "Utilities should be **pure, focused, and framework-agnostic**. They should have **no side effects** (except logger) and **no business logic**."

## Current Structure

```
utils/
└── logger.ts              # Logging utility with colored output
```

**Note**: The current implementation is minimal. File operations and markdown generation have been moved to services layer where they belong.

## Utility Principles

### 1. Pure Functions (Preferred)

Functions should produce the same output for the same input without side effects. The logger is the only exception as its purpose IS side effects (console output).

### 2. Single Responsibility

Each utility function should do exactly one thing and do it well.

### 3. No Business Logic

Utilities should be generic and reusable. Business rules belong in services, not utilities.

### 4. Framework-Agnostic

Utilities should not depend on specific frameworks or libraries when possible. Use standard Node.js APIs.

## File: `logger.ts`

### Purpose

Provides **centralized logging** with colored output for different log levels.

### Implementation

```typescript
import chalk from 'chalk';

export class Logger {
  private static instance: Logger;

  private constructor() {}

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  info(message: string): void {
    console.log(chalk.blue('ℹ'), message);
  }

  success(message: string): void {
    console.log(chalk.green('✓'), message);
  }

  warning(message: string): void {
    console.log(chalk.yellow('⚠'), message);
  }

  error(message: string, error?: Error): void {
    console.error(chalk.red('✗'), message);
    if (error) {
      console.error(chalk.red(error.message));
    }
  }

  debug(message: string): void {
    if (process.env.DEBUG) {
      console.log(chalk.gray('→'), message);
    }
  }
}

// Export singleton instance
export const logger = Logger.getInstance();
```

### Design Decisions

#### 1. Singleton Pattern

```typescript
// ✅ Single logger instance across application
const logger = Logger.getInstance();

// Why not just export functions?
// - Allows configuration (e.g., log level)
// - Easier to mock in tests
// - Can add state (e.g., log buffer)
```

#### 2. Side Effects Are OK Here

```typescript
info(message: string): void {
  console.log(chalk.blue('ℹ'), message); // Side effect is the purpose
}
```

**Exception**: Logger is explicitly designed for side effects (output).

#### 3. Conditional Debug Logging

```typescript
debug(message: string): void {
  if (process.env.DEBUG) {
    console.log(chalk.gray('→'), message);
  }
}
```

**Usage**:
```bash
# Enable debug logging
DEBUG=true node dist/cli.js image.jpg
```

#### 4. Consistent Icons and Colors

```typescript
info:    chalk.blue('ℹ')
success: chalk.green('✓')
warning: chalk.yellow('⚠')
error:   chalk.red('✗')
debug:   chalk.gray('→')
```

**Why**: Visual consistency helps users quickly identify log levels.

### Usage Examples

```typescript
import { logger } from '../utils/logger.js';

// Information
logger.info('Starting file conversion...');

// Success
logger.success('File converted successfully!');

// Warning (non-fatal)
logger.warning('AI service not available, using OCR only');

// Error (with exception object)
try {
  await convert(file);
} catch (error) {
  logger.error('Conversion failed', error as Error);
}

// Debug (only shown when DEBUG=true)
logger.debug(`Processing file: ${filePath}`);
```

### Future Enhancements

```typescript
class Logger {
  private level: LogLevel = LogLevel.INFO;

  setLevel(level: LogLevel): void {
    this.level = level;
  }

  // Only log if message level >= logger level
  info(message: string): void {
    if (this.level <= LogLevel.INFO) {
      console.log(chalk.blue('ℹ'), message);
    }
  }
}

enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARNING = 2,
  ERROR = 3,
}
```

## File: `fileUtils.ts`

### Purpose

Provides **pure utility functions** for common file operations.

### Implementation

```typescript
import { access, constants } from 'fs/promises';
import path from 'path';

export class FileUtils {
  /**
   * Check if file exists and is readable
   * Pure function (no side effects besides I/O check)
   */
  static async fileExists(filePath: string): Promise<boolean> {
    try {
      await access(filePath, constants.R_OK);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get output path by replacing extension with .md
   * Pure function (deterministic transformation)
   */
  static getOutputPath(inputPath: string): string {
    const dir = path.dirname(inputPath);
    const baseName = path.basename(inputPath, path.extname(inputPath));
    return path.join(dir, `${baseName}.md`);
  }

  /**
   * Format bytes to human-readable size
   * Pure function (no side effects)
   */
  static formatFileSize(bytes: number): string {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }

    return `${size.toFixed(2)} ${units[unitIndex]}`;
  }

  /**
   * Check if file has specific extension
   * Pure function (simple check)
   */
  static hasExtension(filePath: string, extensions: string[]): boolean {
    const ext = path.extname(filePath).toLowerCase();
    return extensions.includes(ext);
  }
}
```

### Design Decisions

#### 1. Static Methods (No State)

```typescript
// ✅ Static methods (no instance needed)
const exists = await FileUtils.fileExists(path);

// ❌ Would require instantiation
const utils = new FileUtils();
const exists = await utils.fileExists(path);
```

**Why**: No state to maintain. Pure functions can be static.

#### 2. Class vs. Module

```typescript
// Current: Class with static methods
export class FileUtils {
  static fileExists(path: string): Promise<boolean> { }
}

// Alternative: Exported functions
export function fileExists(path: string): Promise<boolean> { }

// Why class?
// - Namespacing (FileUtils.fileExists is clearer)
// - Easier to mock entire class in tests
// - Can add shared constants
```

#### 3. Pure Transformations

```typescript
// ✅ Pure: input → output, no side effects
static getOutputPath(inputPath: string): string {
  const dir = path.dirname(inputPath);
  const baseName = path.basename(inputPath, path.extname(inputPath));
  return path.join(dir, `${baseName}.md`);
}

// Given "/path/to/image.jpg"
// Always returns "/path/to/image.md"
// Deterministic, no side effects
```

#### 4. Consistent Error Handling

```typescript
static async fileExists(filePath: string): Promise<boolean> {
  try {
    await access(filePath, constants.R_OK);
    return true;
  } catch {
    return false; // Don't throw, return false
  }
}
```

**Why**: Utilities should be resilient. Return `false` instead of throwing.

### Usage Examples

```typescript
import { FileUtils } from '../utils/fileUtils.js';

// Check file existence
if (!await FileUtils.fileExists(filePath)) {
  logger.error('File not found');
  return;
}

// Get output path
const outputPath = FileUtils.getOutputPath(inputPath);
// "/path/to/image.jpg" → "/path/to/image.md"

// Format file size for display
const metadata = {
  fileSize: FileUtils.formatFileSize(stats.size)
};
// 1048576 → "1.00 MB"

// Check extension
if (FileUtils.hasExtension(filePath, ['.jpg', '.png'])) {
  // Process image
}
```

## File: `MarkdownGenerator.ts`

### Purpose

Provides utilities for **generating well-formatted Markdown** documents.

### Implementation

```typescript
import { FileUtils } from './fileUtils.js';

export interface MarkdownSection {
  heading: string;
  content: string;
}

export class MarkdownGenerator {
  /**
   * Generate complete Markdown document
   * Pure function (template-based generation)
   */
  static generate(
    title: string,
    metadata: Record<string, unknown>,
    sections: MarkdownSection[]
  ): string {
    const parts: string[] = [];

    // Title
    parts.push(`# ${title}\n`);

    // Metadata table
    if (Object.keys(metadata).length > 0) {
      parts.push('## Metadata\n');
      parts.push(this.generateMetadataTable(metadata));
      parts.push('');
    }

    // Content sections
    sections.forEach((section) => {
      parts.push(`## ${section.heading}\n`);
      parts.push(section.content);
      parts.push('');
    });

    // Footer
    parts.push('---');
    parts.push('');
    parts.push('*Converted by UnifiedMarkdown*');
    parts.push('');

    return parts.join('\n');
  }

  /**
   * Generate metadata table
   * Private helper (pure function)
   */
  private static generateMetadataTable(
    metadata: Record<string, unknown>
  ): string {
    const rows = Object.entries(metadata).map(([key, value]) => {
      const formattedKey = this.formatMetadataKey(key);
      const formattedValue = this.formatMetadataValue(value);
      return `| **${formattedKey}** | ${formattedValue} |`;
    });

    return ['| Property | Value |', '|----------|-------|', ...rows].join('\n');
  }

  /**
   * Format key for display
   * Pure function (string transformation)
   */
  private static formatMetadataKey(key: string): string {
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (str) => str.toUpperCase())
      .trim();
  }

  /**
   * Format value based on type
   * Pure function (type-aware formatting)
   */
  private static formatMetadataValue(value: unknown): string {
    if (value === null || value === undefined) {
      return 'N/A';
    }

    if (value instanceof Date) {
      return value.toLocaleString();
    }

    if (typeof value === 'number' && value > 1024) {
      return FileUtils.formatFileSize(value);
    }

    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }

    return String(value);
  }

  // Additional utility methods (all pure)
  static codeBlock(content: string, language = ''): string {
    return `\`\`\`${language}\n${content}\n\`\`\``;
  }

  static blockquote(content: string): string {
    return content.split('\n').map((line) => `> ${line}`).join('\n');
  }

  static link(text: string, url: string): string {
    return `[${text}](${url})`;
  }

  static image(altText: string, imagePath: string): string {
    return `![${altText}](${imagePath})`;
  }
}
```

### Design Decisions

#### 1. Pure Template-Based Generation

```typescript
static generate(title: string, metadata: Record, sections: Section[]): string {
  // Input → Output, no side effects
  // Same inputs always produce same output
}
```

**Why**: Deterministic output makes testing easy and behavior predictable.

#### 2. Type-Aware Formatting

```typescript
private static formatMetadataValue(value: unknown): string {
  if (value instanceof Date) return value.toLocaleString();
  if (typeof value === 'number' && value > 1024) {
    return FileUtils.formatFileSize(value);
  }
  if (typeof value === 'boolean') return value ? 'Yes' : 'No';
  return String(value);
}
```

**Why**: Smart formatting improves readability without requiring caller to know details.

#### 3. Composition Over Inheritance

```typescript
// Uses FileUtils.formatFileSize instead of duplicating logic
if (typeof value === 'number' && value > 1024) {
  return FileUtils.formatFileSize(value);
}
```

**Why**: Reuses existing utilities, follows DRY principle.

#### 4. Private Helpers

```typescript
private static generateMetadataTable(metadata): string { }
private static formatMetadataKey(key: string): string { }
private static formatMetadataValue(value: unknown): string { }
```

**Why**: Internal implementation details, not part of public API.

### Usage Examples

```typescript
import { MarkdownGenerator, MarkdownSection } from '../utils/MarkdownGenerator.js';

// Build sections
const sections: MarkdownSection[] = [
  {
    heading: 'Extracted Text (OCR)',
    content: 'Sample text extracted from image...',
  },
  {
    heading: 'Visual Description',
    content: 'AI-generated description of the image...',
  },
];

// Generate complete document
const markdown = MarkdownGenerator.generate(
  'image.jpg',
  {
    fileName: 'image.jpg',
    fileSize: 1048576,
    format: 'JPEG',
    dimensions: '1920 × 1080',
  },
  sections
);

// Use helper methods
const code = MarkdownGenerator.codeBlock('const x = 1;', 'typescript');
const quote = MarkdownGenerator.blockquote('Important note');
const link = MarkdownGenerator.link('GitHub', 'https://github.com');
```

### Output Format

```markdown
# image.jpg

## Metadata

| Property | Value |
|----------|-------|
| **File Name** | image.jpg |
| **File Size** | 1.00 MB |
| **Format** | JPEG |
| **Dimensions** | 1920 × 1080 |

## Extracted Text (OCR)

Sample text extracted from image...

## Visual Description

AI-generated description of the image...

---

*Converted by UnifiedMarkdown*
```

## Best Practices for Utilities

### 1. Prefer Pure Functions

```typescript
// ✅ Pure function
export function formatFileSize(bytes: number): string {
  return `${(bytes / 1024).toFixed(2)} KB`;
}

// ❌ Impure function
let lastSize: number;
export function formatFileSize(bytes: number): string {
  lastSize = bytes; // Side effect: modifies state
  return `${(bytes / 1024).toFixed(2)} KB`;
}
```

### 2. Type Everything

```typescript
// ✅ Explicit types
export function getOutputPath(inputPath: string): string {
  return path.join(path.dirname(inputPath), 'output.md');
}

// ❌ No types
export function getOutputPath(inputPath) {
  return path.join(path.dirname(inputPath), 'output.md');
}
```

### 3. No Business Logic

```typescript
// ✅ Generic utility
export function hasExtension(path: string, exts: string[]): boolean {
  return exts.includes(path.extname(path).toLowerCase());
}

// ❌ Business logic embedded
export function isImage(path: string): boolean {
  const imageExts = ['.jpg', '.png']; // Business rule
  return imageExts.includes(path.extname(path).toLowerCase());
}
```

### 4. Document Edge Cases

```typescript
/**
 * Format file size to human-readable format
 *
 * @param bytes - File size in bytes
 * @returns Formatted size (e.g., "1.50 MB")
 *
 * @example
 * formatFileSize(1024);      // "1.00 KB"
 * formatFileSize(1048576);   // "1.00 MB"
 * formatFileSize(0);         // "0.00 B"
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0.00 B';
  // ...
}
```

### 5. Handle Errors Gracefully

```typescript
// ✅ Return safe default on error
static async fileExists(filePath: string): Promise<boolean> {
  try {
    await access(filePath, constants.R_OK);
    return true;
  } catch {
    return false; // Safe default
  }
}

// ❌ Let exception propagate
static async fileExists(filePath: string): Promise<boolean> {
  await access(filePath, constants.R_OK); // Throws if file doesn't exist
  return true;
}
```

## Testing Utilities

Utilities should be the **easiest to test** because they're pure:

```typescript
describe('FileUtils', () => {
  describe('getOutputPath', () => {
    it('should replace extension with .md', () => {
      const input = '/path/to/image.jpg';
      const output = FileUtils.getOutputPath(input);
      expect(output).toBe('/path/to/image.md');
    });

    it('should handle files without extension', () => {
      const input = '/path/to/file';
      const output = FileUtils.getOutputPath(input);
      expect(output).toBe('/path/to/file.md');
    });
  });

  describe('formatFileSize', () => {
    it('should format bytes', () => {
      expect(FileUtils.formatFileSize(500)).toBe('500.00 B');
    });

    it('should format kilobytes', () => {
      expect(FileUtils.formatFileSize(1024)).toBe('1.00 KB');
    });

    it('should format megabytes', () => {
      expect(FileUtils.formatFileSize(1048576)).toBe('1.00 MB');
    });
  });
});
```

## Common Anti-Patterns

```typescript
// ❌ Utility with side effects
export function processFile(path: string) {
  const content = fs.readFileSync(path); // Side effect
  const transformed = transform(content);
  fs.writeFileSync(outputPath, transformed); // Side effect
  console.log('Done'); // Side effect
}

// ❌ Utility with business logic
export function validateImageFile(path: string): boolean {
  if (!path.endsWith('.jpg') && !path.endsWith('.png')) {
    throw new Error('Invalid image type'); // Business rule
  }
  return true;
}

// ❌ Utility depends on other layers
import { ImageConverter } from '../converters/ImageConverter.js';
export function helperFunction() {
  const converter = new ImageConverter(); // Wrong dependency direction!
}

// ❌ Mutable state in utility
let counter = 0;
export function incrementCounter() {
  counter++; // Shared mutable state
  return counter;
}
```

## Adding New Utilities

### Checklist

- [ ] Is it pure? (no side effects except logger)
- [ ] Is it generic? (no business logic)
- [ ] Is it typed? (explicit types)
- [ ] Is it documented? (JSDoc comments)
- [ ] Is it testable? (deterministic output)
- [ ] Is it reusable? (used by multiple modules)

### Example: Adding String Utilities

```typescript
// src/utils/stringUtils.ts

/**
 * String manipulation utilities
 */
export class StringUtils {
  /**
   * Truncate string to maximum length
   * Pure function (deterministic)
   */
  static truncate(str: string, maxLength: number): string {
    if (str.length <= maxLength) return str;
    return str.slice(0, maxLength - 3) + '...';
  }

  /**
   * Convert camelCase to Title Case
   * Pure function (transformation)
   */
  static camelToTitle(str: string): string {
    return str
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (char) => char.toUpperCase())
      .trim();
  }

  /**
   * Escape Markdown special characters
   * Pure function (escaping)
   */
  static escapeMarkdown(str: string): string {
    const specialChars = /([\\`*_{}[\]()#+\-.!])/g;
    return str.replace(specialChars, '\\$1');
  }
}
```

---

**Key Takeaways**:
1. **Utilities are pure functions** (except logger)
2. **No business logic** in utilities
3. **Type everything explicitly**
4. **Document with examples**
5. **Handle errors gracefully** (return defaults, don't throw)
6. **Keep functions small** and focused

**See Also**:
- Root `.claude.md` for overall architecture
- `core/.claude.md` for domain logic
- `converters/.claude.md` for how converters use utilities
