# Source Directory (`/src`)

## Purpose

This directory contains all TypeScript source code for the UnifiedMarkdown CLI tool. It is organized into layers following **clean architecture** principles and **separation of concerns**.

## Directory Structure

```
src/
├── cli.ts                    # Entry point (Presentation Layer)
├── commands/                 # Command Pattern implementations
│   ├── ConvertCommand.ts     # Main convert command
│   └── ImageCommand.ts       # Legacy image command
├── interfaces/               # Interface definitions (contracts)
│   └── IOCRService.ts        # OCR service interface
├── services/                 # Service implementations
│   ├── AI/                   # AI service integrations
│   │   └── GeminiSingleFileOCRService.ts
│   ├── OCR/                  # OCR strategies
│   │   ├── OCRServiceFactory.ts  # Factory Pattern
│   │   ├── ImageOCRService.ts    # Image processing
│   │   ├── PdfOCRService.ts      # PDF processing
│   │   └── DirectoryOCRService.ts # Batch processing
│   └── MarkdownSaverService.ts   # File management
└── utils/                    # Pure utility functions
    └── logger.ts             # Logging utility
```

## Layered Architecture

```
┌───────────────────────────────────────┐
│     Presentation Layer (CLI)          │  ← cli.ts
├───────────────────────────────────────┤
│     Command Layer (Command Pattern)   │  ← commands/*
├───────────────────────────────────────┤
│     Factory Layer (Service Creation)  │  ← services/OCR/OCRServiceFactory.ts
├───────────────────────────────────────┤
│     Service Layer (Business Logic)    │  ← services/OCR/*, services/AI/*
├───────────────────────────────────────┤
│     Infrastructure Layer (External)   │  ← services/AI/GeminiSingleFileOCRService.ts
├───────────────────────────────────────┤
│     Utility Layer (Helpers)           │  ← utils/*
└───────────────────────────────────────┘
```

### Layer Responsibilities

1. **Presentation Layer** (`cli.ts`)
   - Parse command-line arguments with Commander.js
   - Display output to user
   - Handle user input
   - Register commands
   - **Should NOT** contain business logic

2. **Command Layer** (`commands/`)
   - Encapsulate CLI command logic
   - Validate command arguments
   - Coordinate with factory to get appropriate service
   - Handle command-specific errors
   - **Should NOT** know about service implementations

3. **Factory Layer** (`services/OCR/OCRServiceFactory.ts`)
   - Determine file type from path
   - Create appropriate service instance
   - Centralize service creation logic
   - **Should NOT** contain processing logic

4. **Service Layer** (`services/OCR/*`, `services/MarkdownSaverService.ts`)
   - Implement file-type-specific processing strategies
   - Coordinate between AI service and markdown saver
   - Handle service-specific errors
   - **Should NOT** know about CLI or commands

5. **Infrastructure Layer** (`services/AI/*`)
   - Integrate with external APIs (Google Gemini)
   - Handle API authentication
   - Transform API responses
   - **Should NOT** contain business logic

6. **Utility Layer** (`utils/`)
   - Pure functions (except logger)
   - Logging functionality
   - Reusable across layers
   - **Should NOT** have business logic

## Dependency Rules (Critical!)

```
┌────────────────────────────────────────────────────────┐
│  DEPENDENCY FLOW (One Direction Only)                  │
│                                                         │
│  cli.ts → commands → factory → services → utils        │
│                                                         │
│  ❌ NEVER: factory → commands                          │
│  ❌ NEVER: services → factory                          │
│  ❌ NEVER: utils → services                            │
│  ❌ NEVER: commands → cli.ts                           │
└────────────────────────────────────────────────────────┘
```

**Rule of Thumb**:
- Commands should only depend on factory and interfaces
- Services should only depend on other services and utils
- Factory should only depend on services and interfaces
- Utilities should have NO dependencies on other layers

## File: `cli.ts`

### Purpose
Entry point for the CLI application. Registers commands and handles program initialization.

### Current Implementation

```typescript
async function main() {
  const program = new Command();
  const version = await getVersion();

  program
    .name('umd')
    .description('UnifiedMarkdown - Minimal CLI')
    .version(version);

  registerConvertCommand(program);  // Command Pattern

  program.parse();
}
```

### Best Practices

```typescript
// ✅ CORRECT: Minimal logic, registers commands
async function main() {
  const program = new Command();

  registerConvertCommand(program);
  registerBatchCommand(program);

  program.parse();
}

// ❌ WRONG: Business logic in CLI
async function main() {
  program.action(async (file: string) => {
    const service = new ImageOCRService();
    await service.extractText(file); // Too much detail!
  });
}
```

### Responsibilities
- ✅ Initialize Commander.js program
- ✅ Register commands from commands/ directory
- ✅ Set program name, version, description
- ✅ Handle global CLI errors (exit codes)
- ✅ Load environment variables (dotenv)
- ❌ Never implement command logic
- ❌ Never directly instantiate services

### Extension Points
- Register new commands from commands/ directory
- Add global options using `.option()`
- Configure global error handlers
- Add pre/post hooks for all commands

## Module Organization

### Import Order Convention

```typescript
// 1. Node.js built-ins
import { readFile } from 'fs/promises';
import path from 'path';

// 2. Third-party libraries
import { Command } from 'commander';
import { GoogleGenAI } from '@google/genai';

// 3. Interfaces (abstractions)
import { IOCRService } from './interfaces/IOCRService.js';

// 4. Services (implementations)
import { OCRServiceFactory } from './services/OCR/OCRServiceFactory.js';
import { GeminiSingleFileOCRService } from './services/AI/GeminiSingleFileOCRService.js';

// 5. Utilities
import { logger } from './utils/logger.js';
```

## File Naming Conventions

```
✅ PascalCase for services and classes:
   - ImageOCRService.ts
   - PdfOCRService.ts
   - OCRServiceFactory.ts
   - GeminiSingleFileOCRService.ts
   - MarkdownSaverService.ts

✅ PascalCase with 'I' prefix for interfaces:
   - IOCRService.ts
   - IGeminiOCRService.ts

✅ PascalCase for commands (with Command suffix):
   - ConvertCommand.ts
   - ImageCommand.ts
   - BatchCommand.ts (future)

✅ camelCase for utilities:
   - logger.ts

✅ PascalCase for directories:
   - services/AI/
   - services/OCR/
```

## TypeScript Configuration

All code in `src/` must:
- Use **ES2022 modules** (`.js` imports required)
- Compile to `dist/` with source maps
- Have **strict mode** enabled
- Include **type declarations** (`.d.ts`)

## Code Quality Standards

### 1. Type Safety

```typescript
// ✅ Explicit return types
async function processFile(path: string): Promise<boolean> {
  // ...
}

// ✅ Interface for objects
interface Metadata {
  fileName: string;
  fileSize: number;
}

// ❌ Implicit any
function processData(data) { // Bad: implicit any
  // ...
}
```

### 2. Error Handling

```typescript
// ✅ Return result objects, don't throw
async function convert(path: string): Promise<ConversionResult> {
  try {
    // logic
    return { success: true, content: result };
  } catch (error) {
    return { success: false, error };
  }
}

// ❌ Let exceptions bubble up
async function convert(path: string): Promise<string> {
  return await dangerousOperation(); // Might throw!
}
```

### 3. Dependency Injection

```typescript
// ✅ Constructor injection with interfaces
class ImageConverter {
  constructor(
    private ocrService: IOCRService,
    private aiService: IAIService
  ) {}
}

// ❌ Hard-coded dependencies
class ImageConverter {
  private ocr = new OCRService(); // Tight coupling!
}
```

### 4. Immutability

```typescript
// ✅ Readonly properties
class Converter {
  readonly name: string;
  readonly supportedExtensions: readonly string[];
}

// ✅ Const arrays
const SUPPORTED_FORMATS = ['.jpg', '.png'] as const;

// ❌ Mutable class properties
class Converter {
  name: string; // Can be changed externally
}
```

## Adding New Modules

### When to Create a New Directory

- **New command type**: Add to `commands/`
- **New interface/contract**: Add to `interfaces/`
- **New external service**: Add to `services/AI/` or `services/OCR/`
- **Reusable helper**: Add to `utils/`

### When to Create a New File

```
✅ Create new file when:
   - Class exceeds 200 lines
   - Single Responsibility Principle violated
   - Multiple unrelated functions in one file

❌ Don't create new file for:
   - Simple types (add to existing file)
   - One-off helper functions (add to utils)
   - Configuration constants (add to config)
```

## Testing Strategy (Future)

When adding tests:

```
src/
├── converters/
│   ├── ImageConverter.ts
│   └── ImageConverter.test.ts      ← Co-located tests
├── services/
│   ├── OCRService.ts
│   └── OCRService.test.ts
```

**Test Principles**:
- Test against interfaces, not implementations
- Mock external dependencies
- Test error paths, not just happy path
- Use descriptive test names

## Common Patterns

### 1. Service Registration Pattern

```typescript
// Initialize services
const ocrService = OCRService.getInstance();
const aiService = AIServiceAdapter.getInstance();

// Inject into converter
const converter = new ImageConverter(ocrService, aiService.getProvider());

// Register with processor
processor.registerConverter(converter);
```

### 2. Result Object Pattern

```typescript
// Consistent return type across all converters
interface ConversionResult {
  success: boolean;
  content?: string;
  error?: Error;
  metadata?: Record<string, unknown>;
}
```

### 3. Singleton Pattern

```typescript
// Services use singleton for resource efficiency
class OCRService {
  private static instance: OCRService;

  static getInstance(): OCRService {
    if (!OCRService.instance) {
      OCRService.instance = new OCRService();
    }
    return OCRService.instance;
  }
}
```

## Performance Considerations

### Import Performance

```typescript
// ✅ Import only what you need
import { readFile } from 'fs/promises';

// ❌ Import entire module
import fs from 'fs'; // Brings in unnecessary code
```

### Lazy Loading

```typescript
// ✅ Lazy load heavy dependencies
async function processImage(path: string) {
  const sharp = await import('sharp'); // Load only when needed
  // ...
}

// ❌ Load all dependencies upfront
import sharp from 'sharp'; // Loaded even if not used
```

## Common Mistakes to Avoid

```typescript
// ❌ Circular dependencies
// FileProcessor.ts imports ImageConverter.ts
// ImageConverter.ts imports FileProcessor.ts
// Solution: Use interfaces to break the cycle

// ❌ Mixing concerns
class ImageConverter {
  async convert(path: string) {
    console.log('Converting...'); // Presentation logic in domain!
  }
}
// Solution: Use logger from utils

// ❌ Hard-coded configuration
const API_KEY = 'sk-1234...'; // Never hard-code secrets!
// Solution: Use environment variables

// ❌ Missing error handling
const result = await riskyOperation(); // Might throw!
// Solution: Wrap in try-catch or use Result type
```

## Documentation Standards

### JSDoc Comments

```typescript
/**
 * Convert an image file to Markdown format
 *
 * @param filePath - Absolute path to the image file
 * @returns Conversion result with markdown content
 *
 * @example
 * ```typescript
 * const result = await converter.convert('/path/to/image.jpg');
 * if (result.success) {
 *   console.log(result.content);
 * }
 * ```
 */
async convert(filePath: string): Promise<ConversionResult> {
  // Implementation
}
```

### Code Comments

```typescript
// ✅ Explain WHY, not WHAT
// Use singleton to avoid re-initializing OCR service (expensive operation)
const ocr = OCRService.getInstance();

// ❌ State the obvious
// Get the OCR service instance
const ocr = OCRService.getInstance();
```

## Migration Path

When refactoring or adding features:

1. **Define interface first** (in `core/interfaces/`)
2. **Implement in service** (in `services/` or `converters/`)
3. **Update orchestration** (in `core/FileProcessor.ts`)
4. **Wire up in CLI** (in `cli.ts`)
5. **Test end-to-end**

---

## Directory: `commands/`

Contains **Command Pattern** implementations. Each file exports a `register*Command` function that adds a command to the Commander.js program.

**Pattern**:
```typescript
export function registerXCommand(program: Command) {
  program
    .command('x <arg>')
    .description('...')
    .action(async (arg) => {
      // Get service from factory
      const service = XServiceFactory.getService(arg);
      await service.process(arg);
    });
}
```

**See** `commands/.claude.md` for detailed documentation.

## Directory: `interfaces/`

Contains **interface definitions** that define contracts between layers.

**Current interfaces**:
- `IOCRService`: Contract for OCR service implementations
- `IGeminiOCRService`: Contract for AI service providers

**Pattern**:
```typescript
export interface IXService {
  process(input: string): Promise<void>;
}
```

**See** `interfaces/.claude.md` for detailed documentation.

**See Also**:
- Root `.claude.md` for project overview
- `commands/.claude.md` for command pattern details
- `interfaces/.claude.md` for interface definitions
- `services/.claude.md` for service integration
- `utils/.claude.md` for utility guidelines
