# UnifiedMarkdown Project Context

## Project Overview

UnifiedMarkdown is a **scalable, enterprise-grade Node.js CLI tool** that converts various file types (images, PDFs, directories) to Markdown format. The project is built with **SOLID principles** and **design patterns** as first-class citizens, making it highly maintainable and extensible.

**Current Status**: v0.1.0 - Supports image-to-Markdown, PDF-to-Markdown, and directory batch conversion using Google Gemini AI.

## Core Philosophy

### Software Engineering Principles

1. **SOLID Principles (Strictly Enforced)**
   - **Single Responsibility**: Each class has exactly one reason to change
   - **Open/Closed**: Open for extension, closed for modification
   - **Liskov Substitution**: All implementations are interchangeable
   - **Interface Segregation**: Small, focused interfaces
   - **Dependency Inversion**: Depend on abstractions, not concretions

2. **Design Patterns in Use**
   - **Command Pattern**: Each CLI command is encapsulated in a command class
   - **Factory Pattern**: `OCRServiceFactory` creates appropriate service based on file type
   - **Strategy Pattern**: Different OCR services for different file types (Image, PDF, Directory)
   - **Dependency Injection**: Services injected via constructors
   - **Separation of Concerns**: Clear boundaries between commands, services, and utilities

3. **Code Quality Standards**
   - **Type Safety**: 100% TypeScript with strict mode
   - **No `any` types**: Explicit typing throughout
   - **Immutability**: Use `readonly` for properties that shouldn't change
   - **Pure Functions**: Prefer pure functions in utilities
   - **Error Handling**: Always handle errors gracefully

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                      CLI Layer                          │
│                     (cli.ts)                            │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  Command Layer                          │
│         (ConvertCommand, ImageCommand)                  │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  Factory Layer                          │
│                (OCRServiceFactory)                      │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                   Service Layer                         │
│   (ImageOCRService, PdfOCRService, DirectoryOCRService) │
│              ↓ depends on ↓                             │
│    GeminiSingleFileOCRService, MarkdownSaverService     │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                   Utility Layer                         │
│                    (Logger)                             │
└─────────────────────────────────────────────────────────┘
```

## Key Architectural Decisions

### 1. Command Pattern for CLI Operations

Each CLI command is encapsulated in its own class:

```typescript
// ✅ CORRECT: Command encapsulation
export function registerConvertCommand(program: Command) {
  program
    .command('convert <inputPath>')
    .description('Convert an image, pdf, or directory to markdown')
    .action(async (inputPath) => {
      // Command logic
    });
}

// Each command is independent and focused
```

**Rationale**: Separates CLI argument parsing from business logic. Makes it easy to add new commands without modifying existing code (Open/Closed Principle).

### 2. Factory Pattern for Service Creation

`OCRServiceFactory` creates the appropriate service based on input type:

```typescript
// ✅ Factory creates correct service
export class OCRServiceFactory {
  public static getService(inputPath: string): IOCRService {
    if (isDirectory(inputPath)) return new DirectoryOCRService();
    if (isPDF(inputPath)) return new PdfOCRService();
    if (isImage(inputPath)) return new ImageOCRService();
    throw new Error(`Unsupported file type`);
  }
}
```

**Rationale**: Centralizes service creation logic. Adding new file types only requires modifying the factory, not the commands.

### 3. Strategy Pattern for OCR Services

Each input type has its own OCR service implementation:

```typescript
// Each service is a strategy
class ImageOCRService implements IOCRService { }
class PdfOCRService implements IOCRService { }
class DirectoryOCRService implements IOCRService { }
```

**Rationale**: Different file types require different processing strategies. Each service can optimize for its specific input type.

### 4. Separation of Concerns in Services

Services are decomposed into focused, single-purpose components:

```typescript
// ✅ CORRECT: Focused services
class GeminiSingleFileOCRService {
  async extractText(filePath: string, mimeType: string): Promise<string> { }
}

class MarkdownSaverService {
  saveMarkdown(originalPath: string, content: string): string { }
}

// Used together by OCR services
class ImageOCRService {
  constructor() {
    this.geminiService = new GeminiSingleFileOCRService();
    this.markdownSaver = new MarkdownSaverService();
  }
}
```

**Rationale**: Each service has a single responsibility. Easy to test, maintain, and reuse across different contexts.

## File Organization

```
UnifiedMarkdown/
├── src/
│   ├── cli.ts                        # Entry point - minimal logic
│   ├── commands/                     # Command Pattern implementations
│   │   ├── ConvertCommand.ts         # Convert command (primary)
│   │   └── ImageCommand.ts           # Image command (legacy)
│   ├── interfaces/                   # Interface definitions (DIP)
│   │   └── IOCRService.ts            # OCR service contract
│   ├── services/                     # Service implementations
│   │   ├── AI/                       # AI service integrations
│   │   │   └── GeminiSingleFileOCRService.ts  # Gemini API integration
│   │   ├── OCR/                      # OCR strategy implementations
│   │   │   ├── OCRServiceFactory.ts  # Factory Pattern
│   │   │   ├── ImageOCRService.ts    # Image OCR strategy
│   │   │   ├── PdfOCRService.ts      # PDF OCR strategy
│   │   │   └── DirectoryOCRService.ts # Batch processing strategy
│   │   └── MarkdownSaverService.ts   # Markdown file management
│   └── utils/                        # Pure utility functions
│       └── logger.ts                 # Singleton logger
```

## Adding New Features

### Adding a New File Type (e.g., DOCX)

1. **Create OCR service** in `src/services/OCR/DocxOCRService.ts`:
   ```typescript
   export class DocxOCRService implements IOCRService {
     private geminiService: GeminiSingleFileOCRService;
     private markdownSaver: MarkdownSaverService;

     async extractText(docxPath: string): Promise<void> {
       // Convert DOCX to text using Gemini
       const text = await this.geminiService.extractText(docxPath, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
       this.markdownSaver.saveMarkdown(docxPath, text);
     }
   }
   ```

2. **Update factory** in `src/services/OCR/OCRServiceFactory.ts`:
   ```typescript
   public static getService(inputPath: string): IOCRService {
     const ext = inputPath.split('.').pop()?.toLowerCase();

     if (ext === 'docx') return new DocxOCRService();
     // ... existing conditions
   }
   ```

**That's it!** Commands and other code remain unchanged (Open/Closed Principle).

### Adding a New Command

1. **Create command** in `src/commands/BatchCommand.ts`:
   ```typescript
   export function registerBatchCommand(program: Command) {
     program
       .command('batch <pattern>')
       .description('Batch process files matching a pattern')
       .action(async (pattern) => {
         // Command logic
       });
   }
   ```

2. **Register in CLI** (`src/cli.ts`):
   ```typescript
   import { registerBatchCommand } from './commands/BatchCommand.js';
   registerBatchCommand(program);
   ```

**No existing commands affected** (Command Pattern isolation).

### Adding a New AI Provider (e.g., Claude)

1. **Create provider** in `src/services/AI/ClaudeOCRService.ts`:
   ```typescript
   export class ClaudeOCRService implements IGeminiOCRService {
     async extractText(filePath: string, mimeType: string): Promise<string> {
       // Use @anthropic-ai/sdk
     }
   }
   ```

2. **Use in OCR services** (replace GeminiSingleFileOCRService):
   ```typescript
   class ImageOCRService {
     constructor() {
       this.aiService = new ClaudeOCRService(); // Swap provider
       this.markdownSaver = new MarkdownSaverService();
     }
   }
   ```

## Code Quality Guidelines

### TypeScript Best Practices

```typescript
// ✅ Use readonly for immutable properties
class Converter {
  readonly name: string;
  readonly supportedExtensions: string[];
}

// ✅ Use strict types, never 'any'
async convert(filePath: string): Promise<ConversionResult>

// ✅ Use interfaces for dependency injection
constructor(private ocrService: IOCRService) {}

// ✅ Use async/await, not callbacks
async processFile(path: string): Promise<boolean>

// ✅ Handle all error cases
try {
  await process();
} catch (error) {
  return this.handleError(filePath, error);
}

// ✅ Use discriminated unions for results
type ConversionResult = {
  success: boolean;
  content?: string;
  error?: Error;
}
```

### Error Handling Strategy

```typescript
// ✅ Always return a result object, never throw to caller
async convert(filePath: string): Promise<ConversionResult> {
  try {
    // Processing logic
    return { success: true, content: markdown };
  } catch (error) {
    return this.handleError(filePath, error);
  }
}

// ✅ Log errors with context
logger.error(`Conversion failed for ${filePath}`, error);

// ✅ Graceful degradation
const aiDescription = await this.generateDescription(filePath);
// If AI fails, continue with OCR-only result
```

### Testing Strategy (Future)

When adding tests, follow these patterns:

```typescript
// ✅ Test against interfaces, not implementations
describe('ImageConverter', () => {
  let mockOCR: IOCRService;
  let mockAI: IAIService;
  let converter: ImageConverter;

  beforeEach(() => {
    mockOCR = { extractText: jest.fn() };
    mockAI = { describeImage: jest.fn(), isAvailable: jest.fn() };
    converter = new ImageConverter(mockOCR, mockAI);
  });

  // Tests...
});
```

## Performance Considerations

### Current Optimizations

1. **Singleton Services**: OCR and AI services are singletons to avoid initialization overhead
2. **Lazy Loading**: AI models loaded only when needed
3. **Streaming**: Large files processed in chunks (ready for future)
4. **Parallel Processing**: Architecture supports concurrent file processing

### Future Optimizations

- Worker threads for CPU-intensive operations
- Caching layer for repeated conversions
- Batch processing for multiple files
- Memory-mapped file reading for large files

## Extension Points

The architecture is designed for extension at these points:

1. **New Converters**: Extend `BaseConverter` → implements `IConverter`
2. **New Services**: Implement service interface (e.g., `IOCRService`, `IAIService`)
3. **New Outputs**: Extend `MarkdownGenerator` or create `IOutputFormatter`
4. **New CLI Commands**: Add commands to `cli.ts` using Commander.js
5. **Configuration**: Add config loader implementing `IConfigService`

## Anti-Patterns to Avoid

```typescript
// ❌ AVOID: Tight coupling
class ImageConverter {
  private ocr = new OCRService(); // Hard-coded dependency
}

// ❌ AVOID: God classes
class FileConverter {
  convertImage() {}
  convertPDF() {}
  convertDOCX() {}
  // Too many responsibilities
}

// ❌ AVOID: Leaky abstractions
interface IConverter {
  convert(file: string): Promise<Result>;
  getProviderClient(): ProviderClient; // Implementation detail leaked!
}

// ❌ AVOID: Any types
function process(data: any): any { }

// ❌ AVOID: Side effects in constructors
constructor() {
  this.loadModel(); // Async operation in constructor
}
```

## Development Workflow

```bash
# Development cycle
npm run watch           # Auto-rebuild on changes
npm run dev image.jpg   # Test changes

# Code quality
npm run lint           # Check for issues
npm run lint:fix       # Auto-fix issues
npm run format         # Format code

# Build
npm run build          # Production build
```

## Technology Stack

- **TypeScript 5.7**: Latest features, strict mode enabled
- **Commander.js**: CLI framework (industry standard)
- **Google Gemini AI**: Vision and OCR capabilities via @google/genai
- **Sharp**: Fast image processing (for PDF conversion)
- **Chalk**: Terminal styling
- **Ora**: Terminal spinners for UX
- **Dotenv**: Environment variable management

## Current Features

- **Image to Markdown**: Supports PNG, JPG, JPEG, WebP, GIF, BMP, TIFF, SVG
- **PDF to Markdown**: Converts PDFs to markdown using Gemini AI
- **Directory Processing**: Batch converts all supported files in a directory
- **Smart Backup**: Automatically backs up existing .md files with timestamps
- **Gemini AI Integration**: Uses latest Gemini 3 Pro Preview with high thinking level

## Version History

- **v0.1.0** (Current): Multi-format conversion with Gemini AI

## Contributing Guidelines

When contributing, ensure:

1. **Follow SOLID principles**: Every class should have a single responsibility
2. **Use dependency injection**: Never instantiate dependencies inside a class
3. **Write interface-first**: Define the interface before implementation
4. **Type everything**: No `any` types without explicit justification
5. **Handle all errors**: Never let exceptions bubble unhandled
6. **Document patterns**: Use JSDoc to explain design pattern usage

## Contact & Support

- **Documentation**: See `README.md` for user-facing docs
- **Architecture Questions**: Refer to `.claude.md` files in each directory
- **Issues**: GitHub Issues (when repository is public)

---

**Last Updated**: 2025-11-23
**Maintained By**: UnifiedMarkdown Team
**License**: MIT
